% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/connectivity.R
\name{neuprint_get_adjacency_matrix}
\alias{neuprint_get_adjacency_matrix}
\title{Get a matrix of connectivities between bodies}
\usage{
neuprint_get_adjacency_matrix(
  bodyids = NULL,
  inputids = NULL,
  outputids = NULL,
  threshold = 1L,
  dataset = NULL,
  chunksize = 1000L,
  all_segments = FALSE,
  conn = NULL,
  sparse = FALSE,
  cache = FALSE,
  ...
)
}
\arguments{
\item{bodyids}{the body IDs for neurons/segments (bodies) you wish to query.
This can be in any form understood by \code{\link{neuprint_ids}}.}

\item{inputids, outputids}{identifiers for input and output bodies (use as an
alternative to \code{bodyids})}

\item{threshold}{Return only connections greater than or equal to the
indicated strength (default 1 returns all connections).}

\item{dataset}{optional, a dataset you want to query. If \code{NULL}, the
default specified by your R environ file is used or, failing that the
current connection, is used. See \code{\link{neuprint_login}} for details.}

\item{chunksize}{Split large queries into chunks of this many ids to prevent
server timeouts. The default of 1000 seems to be a reasonable compromise.
Set to \code{Inf} to insist that the query is always sent in one pass only.}

\item{all_segments}{if TRUE, all bodies are considered, if FALSE, only
'Neurons', i.e. bodies with a status roughly traced status.}

\item{conn}{optional, a neuprintr connection object, which also specifies the
neuPrint server. If NULL, the defaults set in your
\code{\link[=Startup]{.Rprofile}} or \code{\link[=Startup]{.Renviron}} are
used. See \code{\link{neuprint_login}} for details.}

\item{sparse}{Whether to return a sparse adjacency matrix (of class
\code{\link[=CsparseMatrix-class]{CsparseMatrix}}). This may be a
particularly good idea for large matrices of >5000 neurons, especially if a
threshold is used to eliminate very numerous weak connections. Default
\code{FALSE}.}

\item{cache}{the query to neuPrint server, so that it does not need to be
repeated. Of course you can save the results, but this may be helpful e.g.
inside a wrapper function that post-processes the results like
\code{hemibrainr::grouped_adjacency_matrix}.}

\item{...}{methods passed to \code{neuprint_login}}
}
\value{
a n x n matrix, where the rows are input neurons and the columns are
  their targets. Only neurons supplied as the argument `bodyids` are
  considered.
}
\description{
Get an adjacency matrix for the synaptic connectivity within a
  set of specified bodies
}
\examples{
\donttest{
# these will mostly be axo-axonic connections between DA2 PNs
neuprint_get_adjacency_matrix('DA2 lPN')

# rectangular matrix with different in/out neurons
neuprint_get_adjacency_matrix(inputids='DA2 lPN', outputids='DL4 adPN')
}
\donttest{
# Note the use of cache=T, which will avoid a subsequent query to the
# neuPrint server if the same information is requested
pnkc=neuprint_get_adjacency_matrix(inputids='name:mPN', outputids='/KC.*',
  cache=TRUE)
hist(colSums(pnkc), xlab = 'PN inputs / KC', br=100)
sum(rowSums(pnkc)>0)
}
\dontrun{
# sparse adjacency matrix
pnkcs=neuprint_get_adjacency_matrix(inputids='name:mPN',
  outputids='/KC.*', sparse=TRUE, cache=TRUE)
library(Matrix)
# PN-KC connectivity is itself sparse, so < 2\% of entries are non zero
nnzero(pnkcs)/length(pnkcs)
# while memory requirements are ~ 5\%
as.numeric(object.size(pnkcs)/object.size(pnkc))
}
}
\seealso{
\code{\link{neuprint_fetch_custom}},
  \code{\link{neuprint_simple_connectivity}},
  \code{\link{neuprint_common_connectivity}},
  \code{\link[=CsparseMatrix-class]{CsparseMatrix}})
}
